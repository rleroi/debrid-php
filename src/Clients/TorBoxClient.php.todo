<?php

declare(strict_types=1);

namespace RLeroi\Debrid\Clients;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\GuzzleException;
use InvalidArgumentException;
use JsonException;
use RLeroi\Debrid\DTOs\CacheCheckResult;
use RLeroi\Debrid\DTOs\DebridFile;
use RLeroi\Debrid\DTOs\DebridTorrent;
use RLeroi\Debrid\Exceptions\DebridException;
use RLeroi\Debrid\Mappers\TorBoxMapper;

final class TorBoxClient implements ClientStrategy
{
    private const BASE_URL = 'https://api.torbox.app/v1/api/';

    public function __construct(private ?string $token, private ?ClientInterface $http = null)
    {
        $this->http ??= new Client();
        $this->mapper = new TorBoxMapper();
    }

    public function setToken(string $token): void
    {
        if (empty($token)) {
            throw new InvalidArgumentException('Token cannot be empty');
        }
        $this->token = $token;
    }

    /**
     * @throws GuzzleException|JsonException|DebridException
     */
    private function request(string $method, string $uri, array $options = []): array
    {
        if (!$this->token) {
            throw new InvalidArgumentException('You must set the token before calling this method');
        }

        $mergedOptions = array_merge([
            'base_uri' => self::BASE_URL,
            'headers' => [
                'Authorization' => 'Bearer ' . $this->token,
                'Accept' => 'application/json',
            ],
        ], $options);

        $response = $this->http->request($method, $uri, $mergedOptions);

        $body = $response->getBody()->getContents();

        $data = json_decode($body, true, flags: JSON_THROW_ON_ERROR);
        if (!$data || !$data['success']) {
            throw new DebridException($data['detail'] ?? 'unknown error');
        }

        return $data;
    }

    /**
     * @throws GuzzleException|JsonException|DebridException
     */
    public function checkCache(string $magnet): CacheCheckResult
    {
        // Extract hash from magnet link
        $infoHash = $this->extractHashFromMagnet($magnet);

        // Check if torrent is already cached
        $cachedInfo = $this->checkCachedTorrent($infoHash);
        
        if (empty($cachedInfo)) {
            return CacheCheckResult::notCached($infoHash);
        }

        return $this->mapper->mapCacheCheck($infoHash, ['data' => [$infoHash => ['files' => $cachedInfo]]]);
    }

    /**
     * @return DebridFile[]
     * @throws GuzzleException|JsonException|DebridException
     */
    public function getCachedFiles(string $magnet): array
    {
        // Step 1: Extract hash from magnet link
        $infoHash = $this->extractHashFromMagnet($magnet);

        // Step 2: Check if torrent is already cached
        $cachedInfo = $this->checkCachedTorrent($infoHash);
        
        if (empty($cachedInfo)) {
            // Torrent is not cached, return empty array
            return [];
        }

        // Step 3: Return DebridFile objects from cached info
        return $this->mapper->mapFiles(['data' => [$infoHash => ['files' => $cachedInfo]]]);
    }

    /**
     * @throws GuzzleException|JsonException|DebridException
     */
    public function isFileCached(string $magnet, string $path): bool
    {
        // Get all cached files and check if the specific path exists
        $cachedFiles = $this->getCachedFiles($magnet);
        foreach ($cachedFiles as $file) {
            if ($file->path === $path) {
                return true;
            }
        }
        return false;
    }

    /**
     * @throws GuzzleException|JsonException|DebridException
     */
    public function getLink(string $magnet, string $path): string
    {
        // Step 1: Extract hash from magnet link
        $infoHash = $this->extractHashFromMagnet($magnet);

        // Step 2: Check if torrent is already cached
        $cachedInfo = $this->checkCachedTorrent($infoHash);
        
        if (empty($cachedInfo)) {
            throw new DebridException("Torrent is not cached. Please add it first using addMagnet().");
        }

        // Step 3: Find the target file in cached info
        $targetFile = null;
        foreach ($cachedInfo as $file) {
            if (isset($file['path']) && $file['path'] === $path) {
                $targetFile = $file;
                break;
            }
        }
        
        if (!$targetFile) {
            throw new DebridException("File not found: {$path}");
        }
        
        // Step 4: Get download link for the cached file
        return $this->getFileDownloadLink($infoHash, $targetFile['id'] ?? $path);
    }

    /**
     * @return string Torrent ID
     * @throws DebridException|GuzzleException|JsonException
     */
    public function addMagnet(string $magnet): string
    {
        $response = $this->request(
            'POST',
            'torrents/createtorrent',
            [
                'form_params' => [
                    'magnet' => $magnet,
                ],
            ],
        );

        return (string)($response['data']['torrent_id'] ?? throw new DebridException('Magnet cannot be added'));
    }

    /**
     * Extract hash from magnet link
     */
    private function extractHashFromMagnet(string $magnet): string
    {
        if (preg_match('/urn:btih:([a-fA-F0-9]{40})/', $magnet, $matches)) {
            return strtolower($matches[1]);
        }
        
        throw new DebridException('Invalid magnet link: Could not extract hash');
    }

    /**
     * Check if torrent is cached
     */
    private function checkCachedTorrent(string $infoHash): array
    {
        try {
            $response = $this->request(
                'GET',
                'torrents/checkcached',
                [
                    'query' => [
                        'hash' => [$infoHash],
                        'format' => 'list',
                        'list_files' => 'true',
                    ],
                ],
            );

            if (isset($response['data'][$infoHash]['files'])) {
                return $response['data'][$infoHash]['files'];
            }

            return [];
        } catch (DebridException $e) {
            // If torrent is not cached, return empty array
            return [];
        }
    }

    /**
     * Get torrent information
     */
    private function getTorrentInfo(string $torrentId): array
    {
        $response = $this->request('GET', "torrents/info/{$torrentId}");
        return $response['data'] ?? [];
    }

    /**
     * Get download link for a specific file
     */
    private function getFileDownloadLink(string $torrentId, string $fileId): string
    {
        $response = $this->request(
            'POST',
            'torrents/download',
            [
                'form_params' => [
                    'torrent_id' => $torrentId,
                    'file_id' => $fileId,
                ],
            ],
        );

        return $response['data']['download_link'] ?? throw new DebridException('Failed to get download link');
    }

    /**
     * @throws GuzzleException|JsonException|DebridException
     */
    public function getTorrent(string $magnet): ?DebridTorrent
    {
        // Extract hash from magnet link
        $infoHash = $this->extractHashFromMagnet($magnet);

        // Check if torrent is already cached
        $cachedInfo = $this->checkCachedTorrent($infoHash);
        
        if (empty($cachedInfo)) {
            return null;
        }

        return $this->mapper->mapTorrent($magnet, ['data' => ['files' => $cachedInfo]]);
    }

    /**
     * Find a file by filename (case-insensitive) across different path structures
     * 
     * @param string $magnet The magnet link
     * @param string $filename The filename to search for
     * @return DebridFile|null The file if found, null otherwise
     * @throws DebridException
     */
    public function findFileByFilename(string $magnet, string $filename): ?DebridFile
    {
        // Check cache first - don't automatically add magnet
        $cacheResult = $this->checkCache($magnet);
        
        if (!$cacheResult->isCached) {
            return null;
        }

        // Get actual files
        $files = $this->getCachedFiles($magnet);
        $targetFilename = strtolower(basename($filename));
        
        foreach ($files as $file) {
            $fileBasename = strtolower(basename($file->path));
            if ($fileBasename === $targetFilename) {
                return $file;
            }
        }
        
        return null;
    }
}
